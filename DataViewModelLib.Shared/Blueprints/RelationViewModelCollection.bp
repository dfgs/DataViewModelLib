{{- func GetDTO }}
	{{- localDTOAttribute = $0.attributes | find "DTOAttribute" }}
	{{- if !localDTOAttribute}}
		#warning no DTO attribute was set on table model class {{$0}}
		{{-ret null}}
	{{-end}}
	{{-localDTO=(localDTOAttribute.parameters | find "Name").value}}
	{{-ret localDTO}}
{{-end }}

{{- func GetRelations
	result = []

	for foreignclass in project.classes | with_attribute "TableViewModelAttribute"
		for property in foreignclass.properties
			attribute = property.attributes | find "ForeignKey"
			if attribute
				isnullable = property.type_name | string.ends_with "?"

				relation = { 
					ForeignTable: foreignclass | GetDTO,
					ForeignKey: property.name,
					ForeignPropertyName: (attribute.parameters | find "ForeignPropertyName").value, 
					ForeignKeyIsNullable: isnullable,
					ForeignKeyType: property.type_name,
					PrimaryPropertyName: (attribute.parameters | find "PrimaryPropertyName").value, 
					PrimaryTable: (attribute.parameters | find "PrimaryTable").value, 
					PrimaryKey: (attribute.parameters | find "PrimaryKey").value, 
					CascadeTrigger: (attribute.parameters | find "CascadeTrigger").value 
				} 
				result = result + [relation]
			end
		end
	end

	ret result
end }}

{{- databaseViewModels = (project.classes  | with_attribute "DatabaseViewModelAttribute") }}
{{- databaseViewModel = databaseViewModels | array.first }}
{{- if !databaseViewModel  }}
#warning no DatabaseViewModel attribute defined in database view model class
{{-ret}}
{{-end}}
{{databaseName=databaseViewModel | GetDTO }}
{{- dto= class | GetDTO }}

{{- -}}

// <auto-generated/>
using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Linq;
using System.ComponentModel;
using System.Windows;
using DataModelLib;
using DataViewModelLib;
{{- for reference in project.references }}
using {{reference}};
{{-end}}
{{-for usingAttribute in class.attributes | with_name "UsingAttribute" }}
using {{(usingAttribute.parameters | find "Namespace").value}};
{{-end}}

namespace {{class.namespace}}
{

	{{-for relation in GetRelations}}
	
	
	public partial class {{relation.PrimaryPropertyName}}ViewModelCollection : IViewModelCollection, IAddViewModelCollection,{{(relation.ForeignKeyIsNullable?" IRemoveViewModelCollection,":"")}} IEnumerable<{{relation.ForeignTable}}ViewModel>, INotifyPropertyChanged, INotifyCollectionChanged
	{
		#nullable enable
		public event PropertyChangedEventHandler? PropertyChanged;
		public event NotifyCollectionChangedEventHandler? CollectionChanged;

		private {{relation.ForeignTable}}ViewModel? selectedItem;
		public {{relation.ForeignTable}}ViewModel? SelectedItem
		{
			get => selectedItem;
			set { selectedItem=value; OnPropertyChanged("SelectedItem"); }
		}
		#nullable disable

		private Models.{{databaseName}}Model databaseModel;
		private {{databaseName}}ViewModel databaseViewModel;
		private Models.{{relation.PrimaryTable}}Model primaryRow;

		private List<{{relation.ForeignTable}}ViewModel> items;
		public int Count
		{
			get => items.Count;
		}

		public {{relation.PrimaryPropertyName}}ViewModelCollection({{databaseName}}ViewModel DatabaseViewModel, Models.{{databaseName}}Model DatabaseModel, Models.{{relation.PrimaryTable}}Model PrimaryRow)
		{
			this.databaseModel=DatabaseModel; 
			this.databaseViewModel=DatabaseViewModel;
			this.primaryRow=PrimaryRow;
			
			this.items=new List<{{relation.ForeignTable}}ViewModel>();
			this.items.AddRange( PrimaryRow.Get{{relation.PrimaryPropertyName}}().Select( item => databaseViewModel.Create{{relation.ForeignTable}}ViewModel(item) ));
						
			this.primaryRow.{{relation.PrimaryPropertyName}}Changed += On{{relation.PrimaryPropertyName}}Changed;

		}

		protected virtual void OnPropertyChanged(string PropertyName)
		{
			if (PropertyChanged!=null) PropertyChanged(this, new PropertyChangedEventArgs(PropertyName));
		}

		#region IEnumerable
		public IEnumerator<{{relation.ForeignTable}}ViewModel> GetEnumerator()
		{
			return items.GetEnumerator();
		}
		IEnumerator IEnumerable.GetEnumerator()
		{
			return items.GetEnumerator();
		}
		#endregion

		#region INotifyCollectionChanged
		protected virtual void OnCollectionChanged(NotifyCollectionChangedEventArgs e)
		{
			if (CollectionChanged != null) CollectionChanged(this, e);
		}
		#endregion

		private void On{{relation.PrimaryPropertyName}}Changed(Tables.{{relation.ForeignTable}} Item, DataLib.TableChangedActions Action, int Index)
		{
			{{relation.ForeignTable}}ViewModel item;

			switch(Action)
			{
				case DataLib.TableChangedActions.Remove:
					item=items[Index];		
					items.RemoveAt(Index);
					OnCollectionChanged(new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Remove, item, Index));
					break;
				case DataLib.TableChangedActions.Add:
					item = databaseViewModel.Create{{relation.ForeignTable}}ViewModel(databaseModel.Create{{relation.ForeignTable}}Model(Item));
					items.Insert(Index,item);
					OnCollectionChanged(new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Add, item, Index));
					break;
				default:
					break;
			}
		}

		public void Add(Tables.{{relation.ForeignTable}} Item)
		{
			Item.{{relation.ForeignKey}} = primaryRow.{{relation.PrimaryKey}};
			databaseModel.Add{{relation.ForeignTable}}(Item);
		}
			
		void IAddViewModelCollection.Add(object Item)
		{
			#nullable enable
			Tables.{{relation.ForeignTable}}? convertedItem;
			#nullable disable
			
			convertedItem = Item as Tables.{{relation.ForeignTable}};
			if (convertedItem==null) return;
			Add(convertedItem);
		}
		
		{{-if relation.ForeignKeyIsNullable}}
		public void Remove({{relation.ForeignTable}}ViewModel Item)
		{
			Item.{{relation.ForeignKey}} = null;
		}
		void IRemoveViewModelCollection.Remove(object Item)
		{
			#nullable enable
			{{relation.ForeignTable}}ViewModel? convertedItem;
			#nullable disable
			
			convertedItem = Item as {{relation.ForeignTable}}ViewModel;
			if (convertedItem==null) return;
			Remove(convertedItem);
		}
		{{-end}}


	}

	{{-end}}
}