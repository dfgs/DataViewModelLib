{{- func GetRelations
	result = []

	for foreignclass in project.classes
		for property in foreignclass.properties
			attribute = property.attributes | find "ForeignKey"
			if attribute
				isnullable = property.type_name | string.ends_with "?"

				relation = { 
					ForeignTable: foreignclass.name,
					ForeignKey: property.name,
					ForeignPropertyName: (attribute.parameters | find "ForeignPropertyName").value, 
					ForeignKeyIsNullable: isnullable,
					PrimaryPropertyName: (attribute.parameters | find "PrimaryPropertyName").value, 
					PrimaryTable: (attribute.parameters | find "PrimaryTable").value, 
					PrimaryKey: (attribute.parameters | find "PrimaryKey").value, 
					CascadeTrigger: (attribute.parameters | find "CascadeTrigger").value 
				} 
				result = result + [relation]
			end
		end
	end

	ret result
end -}}

{{- func where_is_primary
	result = []

	for relation in $0
		if relation.PrimaryTable==class.name
			result = result + [relation]
		end
	end

	ret result
end -}}

{{- func where_is_foreign
	result = []

	for relation in $0
		if relation.ForeignTable==class.name
			result = result + [relation]
		end
	end

	ret result
end -}}

{{- func where_column_is_foreign
	

	for relation in $0
		if relation.ForeignTable==class.name
			if relation.ForeignKey==$1
				ret relation
			end
		end
	end

	ret null
end -}}

{{- func group_by_foreign_table
	result = []

	for relation in $0
		
		groupedrelation=nil
		for item in result
			if item.ForeignTable == relation.ForeignTable
				groupedrelation=item
			end
		end
		if groupedrelation==null 
			groupedrelation = {
				ForeignTable: relation.ForeignTable,
				Relations: []
			}
			result = result + [groupedrelation]
		end
		groupedrelation.Relations = groupedrelation.Relations + [relation]
		
	end

	ret result
end -}}

{{- databases = (project.classes  | with_attribute "DatabaseAttribute") }}
{{- database = databases | array.first }}
{{- if !database  }}
#warning no database attribute defined in database class
{{-ret}}
{{-end}}

{{- dtoAttribute = class.attributes | find "DTOAttribute"  }}
{{- if !dtoAttribute}}
#warning no DTO attribute was set on unit test class {{class.name}}
{{-ret}}
{{-end}}
{{- tableName=(dtoAttribute.parameters | find "Name").value }}


{{- -}}

// <auto-generated/>
using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Linq;
using System.ComponentModel;
using System.Windows;
using DataModelLib;
using DataViewModelLib;

namespace {{class.namespace}}
{
	public partial class {{tableName}}ViewModelCollection : IViewModelCollection, IAddViewModelCollection, IRemoveViewModelCollection, IEnumerable<{{tableName}}ViewModel>, INotifyPropertyChanged, INotifyCollectionChanged
	{
		#nullable enable
		public event PropertyChangedEventHandler? PropertyChanged;
		public event NotifyCollectionChangedEventHandler? CollectionChanged;

		private {{tableName}}ViewModel? selectedItem;
		public {{tableName}}ViewModel? SelectedItem
		{
			get => selectedItem;
			set { selectedItem=value; OnPropertyChanged("SelectedItem"); }
		}
		#nullable disable
						
		private Models.{{database.name}}Model databaseModel;
		private {{database.name}}ViewModel databaseViewModel;
			
		private List<{{tableName}}ViewModel> items;
		public int Count
		{
			get => items.Count;
		}

		public {{tableName}}ViewModelCollection({{database.name}}ViewModel DatabaseViewModel, Models.{{database.name}}Model DatabaseModel)
		{
			this.databaseModel=DatabaseModel; 
			this.databaseViewModel=DatabaseViewModel; 
			
			this.items=new List<{{tableName}}ViewModel>();
			this.items.AddRange( databaseModel.Get{{tableName}}Table().Select( item => databaseViewModel.Create{{tableName}}ViewModel(item) ));
			
			this.databaseModel.{{tableName}}TableChanged += On{{tableName}}TableChanged;
		}

		protected virtual void On{{tableName}}TableChanged({{tableName}} Item,TableChangedActions Action, int Index)
		{
			{{tableName}}ViewModel item;
						
			switch(Action)
			{
				case TableChangedActions.Remove:
					item=items[Index];		
					items.RemoveAt(Index);
					OnCollectionChanged(new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Remove, item, Index));
					break;
				case TableChangedActions.Add:
					item = databaseViewModel.Create{{tableName}}ViewModel(databaseModel.Create{{tableName}}Model(Item));
					items.Insert(Index,item);
					OnCollectionChanged(new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Add, item, Index));
					break;
				default:
					break;
			}
		}
			
		protected virtual void OnPropertyChanged(string PropertyName)
		{
			if (PropertyChanged!=null) PropertyChanged(this, new PropertyChangedEventArgs(PropertyName));
		}
			

		#region IEnumerable
		public IEnumerator<{{tableName}}ViewModel> GetEnumerator()
		{
			return items.GetEnumerator();
		}
		IEnumerator IEnumerable.GetEnumerator()
		{
			return items.GetEnumerator();
		}
		#endregion
					
		#region INotifyCollectionChanged
		protected virtual void OnCollectionChanged(NotifyCollectionChangedEventArgs e)
		{
			if (CollectionChanged != null) CollectionChanged(this, e);
		}
		#endregion
			
		public void Remove({{tableName}}ViewModel Item)
		{
			Item.Delete();
		}

		public void Add({{tableName}} Item)
		{
			databaseModel.Add{{tableName}}(Item);
		}

		void IAddViewModelCollection.Add(object Item)
		{
			#nullable enable
			{{tableName}}? convertedItem;
			#nullable disable
			
			convertedItem = Item as {{tableName}};
			if (convertedItem==null) return;
			Add(convertedItem);
		}

		void IRemoveViewModelCollection.Remove(object Item)
		{
			#nullable enable
			{{tableName}}ViewModel? convertedItem;
			#nullable disable
			
			convertedItem = Item as {{tableName}}ViewModel;
			if (convertedItem==null) return;
			Remove(convertedItem);
		}

	}
}