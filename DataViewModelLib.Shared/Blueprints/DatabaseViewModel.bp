{{- func GetRelations
	result = []

	for foreignclass in project.classes
		for property in foreignclass.properties
			attribute = property.attributes | find "ForeignKey"
			if attribute
				isnullable = property.type_name | string.ends_with "?"

				relation = { 
					ForeignTable: foreignclass.name,
					ForeignKey: property.name,
					ForeignPropertyName: (attribute.parameters | find "ForeignPropertyName").value, 
					ForeignKeyIsNullable: isnullable,
					ForeignKeyType: property.type_name,
					PrimaryPropertyName: (attribute.parameters | find "PrimaryPropertyName").value, 
					PrimaryTable: (attribute.parameters | find "PrimaryTable").value, 
					PrimaryKey: (attribute.parameters | find "PrimaryKey").value, 
					CascadeTrigger: (attribute.parameters | find "CascadeTrigger").value 
				} 
				result = result + [relation]
			end
		end
	end

	ret result
end }}
// <auto-generated/>
using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Linq;
using DataModelLib;

namespace {{class.namespace}}.ViewModels
{
	public partial class {{class.name}}ViewModel
	{
		{{- for class in project.classes | with_attribute "TableAttribute" }}
		// events definition for table {{class.name}}
		public event TableChangedEventHandler<{{class.name}}> {{class.name}}TableChanging;
		public event TableChangedEventHandler<{{class.name}}> {{class.name}}TableChanged;
		public event RowChangedEventHandler<{{class.name}}> {{class.name}}RowChanging;
		public event RowChangedEventHandler<{{class.name}}> {{class.name}}RowChanged;
		{{- end }}

		{{- for class in project.classes | with_attribute "TableAttribute" }}
		private Dictionary<{{class.name}},{{class.name}}Model> {{class.name}}Dictionary;
		{{- end }}


		private {{class.name}} dataSource;

		public {{class.name}}Model({{class.name}} DataSource)
		{
			this.dataSource=DataSource;

			{{- for class in project.classes | with_attribute "TableAttribute" }}
			{{class.name}}Dictionary =  new Dictionary<{{class.name}},{{class.name}}Model> ();
			{{- end }}
		}			

	
		{{- for table in project.classes | with_attribute "TableAttribute" }}
		#region table {{table.name}}
		{{- primarykey = table.properties | with_attribute "PrimaryKey" | array.first }}
		{{- if primarykey }}
		public void Remove{{table.name}}({{table.name}}Model Item)
		{
			#nullable enable
			{{table.name}}? dataSourceItem;
			#nullable disable
			int index;

					
			dataSourceItem=dataSource.{{table.name}}Table.FirstOrDefault(item=>item.{{primarykey.name}} == Item.{{primarykey.name}});
			if (dataSourceItem == null) return;
			index=dataSource.{{table.name}}Table.IndexOf(dataSourceItem);

			if ({{table.name}}TableChanging != null) {{table.name}}TableChanging(dataSourceItem,TableChangedActions.Remove, index);
				
			dataSource.{{table.name}}Table.Remove(dataSourceItem);
				
			// cascade update should be triggered before cascade delete
			#region cascade update actions
			{{-for relation in GetRelations}}
			{{- if relation.PrimaryTable==table.name}}
			{{- if relation.CascadeTrigger=="CascadeTriggers.Update"}}
			{{- if relation.ForeignKeyIsNullable}}
			// Cascade update from relation {{relation.ForeignTable}}.{{relation.ForeignKey}} -> {{relation.PrimaryTable}}.{{relation.PrimaryKey}}
			foreach({{relation.ForeignTable}}Model foreignItem in Get{{relation.ForeignTable}}Table(foreignItem=>foreignItem.{{relation.ForeignKey}} == Item.{{relation.PrimaryKey}}).ToArray())
			{
				foreignItem.{{relation.ForeignKey}} = null;
			}
			{{-else}}
			// Cascade update from relation  {{relation.ForeignTable}}.{{relation.ForeignKey}} -> {{relation.PrimaryTable}}.{{relation.PrimaryKey}}
			{{relation.ForeignKeyType}} fallBackValue = Get{{relation.PrimaryTable}}Table().First(item=>item!=Item).{{relation.PrimaryKey}};
			foreach({{relation.ForeignTable}}Model foreignItem in Get{{relation.ForeignTable}}Table(foreignItem=>foreignItem.{{relation.ForeignKey}} == Item.{{relation.PrimaryKey}}).ToArray())
			{
				foreignItem.{{relation.ForeignKey}} = fallBackValue;
			}
			{{-end}}
			{{-end}}
			{{-end}}
			{{-end}}

			{{-for relation in GetRelations}}
			{{- if relation.PrimaryTable==table.name}}
			{{- if relation.CascadeTrigger=="CascadeTriggers.Delete"}}
			// Cascade delete from relation {{relation.ForeignTable}}.{{relation.ForeignKey}} -> {{relation.PrimaryTable}}.{{relation.PrimaryKey}}
			foreach({{relation.ForeignTable}}Model foreignItem in Get{{relation.ForeignTable}}Table(foreignItem=>foreignItem.{{relation.ForeignKey}} == Item.{{relation.PrimaryKey}}).ToArray())
			{
				foreignItem.Delete();
			}
			{{-end}}
			{{-end}}
			{{-end}}
			#endregion

			if ({{table.name}}TableChanged != null) {{table.name}}TableChanged(dataSourceItem,TableChangedActions.Remove, index);
		}
		{{- end }}

		public {{table.name}}Model Get{{table.name}}(Func<{{table.name}},bool> Predicate)
		{
			return Create{{table.name}}Model(dataSource.{{table.name}}Table.First(Predicate));
		}
		{{- if primarykey }}
		public {{table.name}}Model Get{{table.name}}({{primarykey.type_name}} {{primarykey.name}})
		{
			return Get{{table.name}}(item=>item.{{primarykey.name}} == {{primarykey.name}});
		}
		{{- end }}

		public IEnumerable<{{table.name}}Model> Get{{table.name}}Table()
		{
			return dataSource.{{table.name}}Table.Select(item=> Create{{table.name}}Model(item));
		}
		public IEnumerable<{{table.name}}Model> Get{{table.name}}Table(Func<{{table.name}},bool> Predicate)
		{
			return dataSource.{{table.name}}Table.Where(Predicate).Select(item=>Create{{table.name}}Model(item));
		}
		public void Add{{table.name}}({{table.name}} Item)
		{
			int index;

			if (dataSource.{{table.name}}Table.Contains(Item)) return;

			index = dataSource.{{table.name}}Table.Count;
			if ({{table.name}}TableChanging != null) {{table.name}}TableChanging(Item,TableChangedActions.Add, index);
			dataSource.{{table.name}}Table.Add(Item);
			if ({{table.name}}TableChanged != null) {{table.name}}TableChanged(Item,TableChangedActions.Add, index);
		}
		{{removeMethod}}

		public void Notify{{table.name}}RowChanging({{table.name}} Item, string PropertyName, object OldValue, object NewValue)
		{
			if ({{table.name}}RowChanging != null) {{table.name}}RowChanging(Item,PropertyName,OldValue,NewValue);
		}
		public void Notify{{table.name}}RowChanged({{table.name}} Item, string PropertyName, object OldValue, object NewValue)
		{
			if ({{table.name}}RowChanged != null) {{table.name}}RowChanged(Item,PropertyName,OldValue,NewValue);
		}
			
		public {{table.name}}Model Create{{table.name}}Model({{table.name}} Item)
		{
			{{table.name}}Model model;
			
			if (Item==null) throw new ArgumentNullException(nameof(Item));
			
			if (!{{table.name}}Dictionary.TryGetValue(Item,out model))
			{
				model=new {{table.name}}Model(this, Item);
				{{table.name}}Dictionary.Add(Item,model);
			}

			return model;
		}
		#endregion

		{{- end }}

		


	}
}